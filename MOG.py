# -*- coding: utf-8 -*-
"""
Created on Tue Apr  4 

@author: Dimitrios Kyriakis
"""
import sys
import scipy
import scipy.stats
import math as mt
import numpy as np, numpy.random
from Functions_Kyriakis import*
from sklearn.metrics import silhouette_score


#== Probability Density Function
def pdf(X,M,S):
    D= X.shape[0]
    X = X.reshape(D,1)
    p = np.sqrt(((2*mt.pi)**D)*np.linalg.det(S))
    x_til = (X.reshape(D,1)-M.reshape(D,1))
    e =  mt.exp((-1/2)*(x_til).reshape(1,D).dot(np.linalg.inv(S)).dot(x_til.reshape(D,1)))
    s = e/p
    return s

#===================================================================================================#
##################################### MIXTURE OF GAUSSIANS ##########################################
#===================================================================================================#

def MOG(X,k,reps,MEANS,maxiters):
    import scipy.spatial.distance
    N =X.shape[1]
    D = X.shape[0]
    names = ["C"+str(x) for x in range(k)]
    ############## NORMALIZATION #################
#    X, mean_matrix, max_min = Normalization(X)
    for rep in range(reps): 
        #=====================================================================#
        ########################### INITIALIZE ################################
        #=====================================================================#
        ##  CREATE MEANS ##
        
        try:
            Mean_Matrix_old = MEANS.copy()
        except:
            indx = np.random.randint(X.shape[1],size=k)
            Mean_Matrix_old = X[:,indx] # DXK
            
        S_dic_Matrx_old ={}
        for q in names:
            S_dic_Matrx_old[q] = np.eye(D,D)#+np.random.uniform(D,D)
        ## CREATE Πκ ##
        πk_old = (np.random.dirichlet(np.ones(k),size=1)[0]) #np.ones(k)*1/k #

        ## ZERO GAMMA ##
        Diff =1
        e = 1e-7 
        Log_old = -mt.inf
        silhouette_avg_old = 0
        #=====================================================================#
        ####################### CHECK CONVERGE ################################
        #=====================================================================#
        maxit = maxiters
        while Diff > e:
            maxit -=1
            Mean_Matrix_new= np.zeros((D,k))
            S_dic_Matrix_new = {}
            for q in names:
                S_dic_Matrix_new[q] = np.zeros((D,D))
            πk_new = np.zeros((1,k))[0]
            Gamma_Matrix = np.zeros((k,N))
            Marginal_Matrix = np.zeros((1,N))[0]
#            Nk_list = np.zeros((1,k)) # [1xk]
            labels = []
            
            #=================================================================#
            ######################## E-STEP ###################################
            #=================================================================#
            for n in range(N):
                #=============================================================#
                ################# CALCULATE MARGINAL ##########################
                #=============================================================#
                ##################### Responsibility ##########################
                ####### Probability that xi was generated by Gaussian Nk. #####
                #=============================================================#
                
                for cluster in range(k):
                    name = "C{}".format(cluster)
                    pdf_Xn = πk_old[cluster]*pdf(X[:,n],Mean_Matrix_old[:,cluster],S_dic_Matrx_old[name])
                    Gamma_Matrix[cluster,n] = pdf_Xn 
                    Marginal_Matrix[n] += pdf_Xn
            Marginal_Matrix_A = np.repeat(Marginal_Matrix.reshape(1,N),k,axis=0)
            Gamma_Matrix = Gamma_Matrix/Marginal_Matrix_A    
            #=================================================================#
            ########################## M-STEP #################################
            #################### Mnew S_new Πκ_new ############################
            #=================================================================#
            labels = np.argmax(Gamma_Matrix, axis=0)
            Nk = np.sum(Gamma_Matrix,axis=1)
            N_all = np.sum(Nk)
            for n in range(N):
                for cluster in range(k):
                    Mean_Matrix_new[:,cluster] += (Gamma_Matrix[cluster,n])*X[:,n]
            for cluster in range(k):
                Mean_Matrix_new[:,cluster]= Mean_Matrix_new[:,cluster]/Nk[cluster]
            for n in range(N):
                for cluster in range(k):
                    name = "C{}".format(cluster)
                    Xtil = (X[:,n]-Mean_Matrix_new[:,cluster])
                    S_dic_Matrix_new[name] += (Gamma_Matrix[cluster,n])*Xtil.reshape(D,1).dot(Xtil.reshape(1,D))
            for cluster in range(k):
                name = "C{}".format(cluster)
                πk_new[cluster] = Nk[cluster]/N_all
                S_dic_Matrix_new[name]= S_dic_Matrix_new[name]/Nk[cluster]
                           
            #=================================================================#
            ########################### EVALUATE ##############################
            #=================================================================#
            Log_new = np.sum(np.log(Marginal_Matrix))
            Diff = abs(Log_new - Log_old)
            sys.stdout.write("\rDIFF_W: {:.2e}\t Repetition : {}".format(Diff,rep+1))
            sys.stdout.flush()
            Log_old = Log_new
            #RE-ASSIGN OLDS ##
            Mean_Matrix_old = Mean_Matrix_new.copy()
            S_dic_Matrx_old = S_dic_Matrix_new.copy()
            πk_old = πk_new.copy()
            if maxit == 0:
                break
        #=====================================================================#
        #########################  RE CALCULATE Gnk ###########################
        #=====================================================================#
        Marginal_Matrix = np.zeros((1,N))
        for n in range(N):
            for cluster in range(k):
                name = "C{}".format(cluster)
                pdf_Xn = πk_old[cluster]*pdf(X[:,n],Mean_Matrix_old[:,cluster],S_dic_Matrx_old[name])
                Gamma_Matrix[cluster,n] = pdf_Xn 
                Marginal_Matrix[0][n] += pdf_Xn
        Marginal_Matrix_A = np.repeat(Marginal_Matrix,k,axis=0)
        Gamma_Matrix = Gamma_Matrix/Marginal_Matrix_A  
#        Marginal_Matrix_A = np.repeat(Marginal_Matrix,k,axis=0)
#        Gamma_Matrix = Gamma_Matrix/Marginal_Matrix_A    
        labels = np.argmax(Gamma_Matrix, axis=0)
        # Try silhouette because a clusters can be empty
        Cluster_DIC ={}
        for cluster in range(k):
            Cluster_DIC[cluster] = X[:,labels==cluster]
        
        ##### TWO METHODS FOR BEST REPETITIONS #############
        ## DISTANCCE BETWEEN CLUSTERS ##
        dist_C_new = 0
        for cl in Cluster_DIC.keys():
            dist_C_new += scipy.spatial.distance.pdist(Cluster_DIC[cl],"euclidean")[0]
        if rep == 0:
             Centroids = Mean_Matrix_new.copy()
             S_OR = S_dic_Matrix_new.copy()
             dist_C_old = dist_C_new
             cl_labels = np.ndarray.tolist(labels)
             Gamma_Matrix_F = Gamma_Matrix.copy()
        else:
            if dist_C_new < dist_C_old:
                Centroids = Mean_Matrix_new.copy()
                S_OR = S_dic_Matrix_new.copy()
                dist_C_old = dist_C_new
                cl_labels = np.ndarray.tolist(labels)
                Gamma_Matrix_F = Gamma_Matrix.copy()
        
        ## SILHOUETTE SCORE ###
        ## Try silhouette because a clusters can be empty
#        if rep ==0:
#            Centroids = Mean_Matrix_new.copy()
#            S_OR = S_dic_Matrix_new.copy()
#            cl_labels = np.ndarray.tolist(labels)
#        try:
#            silhouette_avg = silhouette_score(X.T, labels,metric='euclidean')        
#        except:
#            silhouette_avg = -1
#        if silhouette_avg > silhouette_avg_old:
#            cl_labels = np.ndarray.tolist(labels)
#            silhouette_avg_old = silhouette_avg
#            Centroids = Mean_Matrix_new.copy()
#            S_OR = S_dic_Matrix_new.copy()

    #=========================================================================#
    #################### CONVER MEANS TO CENTROID MATRIX ######################
    #=========================================================================#
    
#    Centroids = np.concatenate((Mean_Matrix_new[:,0].reshape(2,1),Mean_Matrix_new[:,1].reshape(2,1)),axis=1)
    #### RE SCALE CENTROIDS ###
#    Centroids  = (Centroids*max_min[:,:k])+mean_matrix[:,:k]
    return Centroids, cl_labels,S_OR,Gamma_Matrix_F